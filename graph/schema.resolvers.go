package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.81

import (
	"context"
	"fmt"

	"github.com/google/uuid"
	"github.com/jefersonprimer/chatear-backend/graph/model"
	"github.com/jefersonprimer/chatear-backend/presentation/http"
	"github.com/jefersonprimer/chatear-backend/shared/auth"
)

// RegisterUser is the resolver for the registerUser field.
func (r *mutationResolver) RegisterUser(ctx context.Context, input model.RegisterUserInput) (*model.AuthResponse, error) {
	authTokens, user, err := r.Resolver.UserAppService.Register(ctx, input.Name, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	modelUser := &model.User{
		ID:              user.ID.String(),
		Name:            user.Name,
		Email:           user.Email,
		CreatedAt:       user.CreatedAt.String(),
		UpdatedAt:       user.UpdatedAt.String(),
		IsEmailVerified: user.IsEmailVerified,
		IsDeleted:       user.IsDeleted,
	}

	if user.DeletedAt != nil {
		deletedAtStr := user.DeletedAt.String()
		modelUser.DeletedAt = &deletedAtStr
	}
	if user.AvatarURL != nil {
		modelUser.AvatarURL = user.AvatarURL
	}
	if user.DeletionDueAt != nil {
		deletionDueAtStr := user.DeletionDueAt.String()
		modelUser.DeletionDueAt = &deletionDueAtStr
	}
	if user.LastLoginAt != nil {
		lastLoginAtStr := user.LastLoginAt.String()
		modelUser.LastLoginAt = &lastLoginAtStr
	}

	return &model.AuthResponse{User: modelUser, AccessToken: authTokens.AccessToken, RefreshToken: authTokens.RefreshToken}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthResponse, error) {
	ginCtx, ok := http.GinContextFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("gin context not found")
	}
	loginResponse, err := r.Resolver.UserAppService.Login(ctx, input.Email, input.Password, ginCtx.ClientIP(), ginCtx.Request.UserAgent())
	if err != nil {
		return nil, err
	}

	// This part is duplicated, I should refactor it later
	user, err := r.Resolver.UserAppService.GetUserByEmail(ctx, input.Email)
	if err != nil {
		return nil, err
	}

	modelUser := &model.User{
		ID:              user.ID.String(),
		Name:            user.Name,
		Email:           user.Email,
		CreatedAt:       user.CreatedAt.String(),
		UpdatedAt:       user.UpdatedAt.String(),
		IsEmailVerified: user.IsEmailVerified,
		IsDeleted:       user.IsDeleted,
	}

	if user.DeletedAt != nil {
		deletedAtStr := user.DeletedAt.String()
		modelUser.DeletedAt = &deletedAtStr
	}
	if user.AvatarURL != nil {
		modelUser.AvatarURL = user.AvatarURL
	}
	if user.DeletionDueAt != nil {
		deletionDueAtStr := user.DeletionDueAt.String()
		modelUser.DeletionDueAt = &deletionDueAtStr
	}
	if user.LastLoginAt != nil {
		lastLoginAtStr := user.LastLoginAt.String()
		modelUser.LastLoginAt = &lastLoginAtStr
	}

	return &model.AuthResponse{User: modelUser, AccessToken: loginResponse.AccessToken, RefreshToken: loginResponse.RefreshToken}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	accessToken, err := auth.GetAccessTokenFromContext(ctx) // Assuming a new helper function GetAccessTokenFromContext
	if err != nil {
		return false, fmt.Errorf("access token not found in context: %w", err)
	}
	refreshToken, err := auth.GetRefreshTokenFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("refresh token not found in context: %w", err)
	}

	err = r.Resolver.UserAppService.Logout(ctx, accessToken, refreshToken)
	if err != nil {
		return false, err
	}
	return true, nil
}

// RecoverPassword is the resolver for the recoverPassword field.
func (r *mutationResolver) RecoverPassword(ctx context.Context, input model.RecoverPasswordInput) (bool, error) {
	err := r.Resolver.UserAppService.RecoverPassword(ctx, input.Email)
	if err != nil {
		return false, err
	}
	return true, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, input model.DeleteAccountInput) (bool, error) {
	userID, err := uuid.Parse(input.UserID)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %w", err)
	}

	// Assuming password is not required for GraphQL mutation, or handled by separate auth
	err = r.Resolver.UserAppService.DeleteAccount(ctx, userID)
	if err != nil {
		return false, err
	}
	return true, nil
}

// RecoverAccount is the resolver for the recoverAccount field.
func (r *mutationResolver) RecoverAccount(ctx context.Context, input model.RecoverAccountInput) (bool, error) {
	_, _, err := r.Resolver.UserAppService.RecoverAccount(ctx, input.Token, input.NewPassword)
	if err != nil {
		return false, err
	}

	return true, nil
}

// VerifyEmail is the resolver for the verifyEmail field.
func (r *mutationResolver) VerifyEmail(ctx context.Context, input model.VerifyEmailInput) (bool, error) {
	err := r.Resolver.UserAppService.VerifyEmail(ctx, input.Token)
	if err != nil {
		return false, err
	}
	return true, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.RefreshTokenInput) (*model.AuthResponse, error) {
	authTokens, user, err := r.Resolver.UserAppService.RefreshToken(ctx, input.RefreshToken)
	if err != nil {
		return nil, err
	}

	modelUser := &model.User{
		ID:              user.ID.String(),
		Name:            user.Name,
		Email:           user.Email,
		CreatedAt:       user.CreatedAt.String(),
		UpdatedAt:       user.UpdatedAt.String(),
		IsEmailVerified: user.IsEmailVerified,
		IsDeleted:       user.IsDeleted,
	}

	if user.DeletedAt != nil {
		deletedAtStr := user.DeletedAt.String()
		modelUser.DeletedAt = &deletedAtStr
	}
	if user.AvatarURL != nil {
		modelUser.AvatarURL = user.AvatarURL
	}
	if user.DeletionDueAt != nil {
		deletionDueAtStr := user.DeletionDueAt.String()
		modelUser.DeletionDueAt = &deletionDueAtStr
	}
	if user.LastLoginAt != nil {
		lastLoginAtStr := user.LastLoginAt.String()
		modelUser.LastLoginAt = &lastLoginAtStr
	}

	return &model.AuthResponse{User: modelUser, AccessToken: authTokens.AccessToken, RefreshToken: authTokens.RefreshToken}, nil
}

// Hello is the resolver for the hello field.
func (r *queryResolver) Hello(ctx context.Context) (string, error) {
	return "Hello from GraphQL!", nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
